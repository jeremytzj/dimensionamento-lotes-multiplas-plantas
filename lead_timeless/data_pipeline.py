# -*- coding: utf-8 -*-
"""data_pipeline2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16wM8M_sR7I8XMCjoxhpCVZm0CzRILo2u
"""

# dados do problema

import pandas as pd

periodos = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Periods')
plantas = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Plants', decimal=",")
linhas = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Lines')
cds = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Dist. Centers', decimal=",")
clientes = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Customers', decimal=",")
produtos = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Products')
rotas = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Routes', decimal=",")
demandas = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Demands')
capabilidades = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Capabilities')
ktaxas = pd.read_excel('./sample_data/planilha_inicial.xlsx', sheet_name='Rates')


"""#Conjuntos"""

P = plantas['name'].tolist() # set plants
W = cds['name'].tolist() # set warehouses
Lines = linhas['name'].tolist() # set Line names
plants_of_lines = linhas['plant'].tolist()

p_l = dict(zip(Lines,plants_of_lines))

k = {}
for _, i in ktaxas.iterrows():
  # var = i.to_dict()
  line, period, size, rate = i['line'], i['period'], i['size'], i['rate']
  k[(size,line,period)] = rate

C = clientes['name'].tolist()
I = produtos['product'].tolist()
E = produtos['size'].tolist()
T = periodos['periods'].tolist()
size_of_products = dict(zip(I,E)) #tamanho de cada produto
tamanhos = list(set(E))
products_per_size = {i:[] for i in tamanhos} # produtos por tamanho
for i in I:
  products_per_size[size_of_products[i]].append(i)


#relate products to sizes

def prod_size(prod=None, size=None):
  if prod != None:
    return size_of_products[prod]
  elif size != None:
    return products_per_size[size]

"""#Parametros"""

G_p = dict(zip(P, list(plantas['storage_capacity']))) # capacidade max das plantas
G_w = dict(zip(W, list(cds['storage_capacity']))) # capacidade max dos warehouses
taxas = k # taxas por linha linha plant0_1:{periodo_t:{size:12oz, rate:k}}

t_pc = {} # taxa de frete | indexado por t_pc[(planta_p, cliente_c)]
for _,i in rotas.iterrows():
  if i.origin[0] == "P" and i.destination[0] == "C":
    org, dest, cost = i.origin, i .destination, i.unit_freight_cost
    t_pc[(org, dest)] = cost


t_wc = {} # taxa de frete | indexado por t_wc[(warehouse_w, cliente_c)]
for _,i in rotas.iterrows():
  if i.origin[0] == "W" and i.destination[0] == "C":
    org, dest, cost = i.origin, i .destination, i.unit_freight_cost
    t_wc[(org, dest)] = cost


t_pp = {} # taxa de frete | indexado por t_pp[(planta_p, planta_q)]
for _,i in rotas.iterrows():
  if i.origin[0] == "P" and i.destination[0] == "P":
    org, dest, cost = i.origin, i .destination, i.unit_freight_cost
    t_pp[(org, dest)] = cost


t_pw = {} # taxa de frete | indexado por t_pp[(planta_p, planta_q)]
for _,i in rotas.iterrows():
  if i.origin[0] == "P" and i.destination[0] == "W":
    org, dest, cost = i.origin, i .destination, i.unit_freight_cost
    t_pw[(org, dest)] = cost


D = {} # Demandas | indexado por D[(customer_c, product_i, period_t)]
for _,r in demandas.iterrows():
  client, prod, perio , demand = r['customer'], r['product'], r['period'], r['demand']
  D[(client, prod, perio)] = demand

holding_cost = 0.1
M = 10 # penalizacao por falta a demanda
truck_capacity = 250000
estoque_inicial_p = {i:0 for i in P}
estoque_inicial_w = {i:0 for i in W}

"""calcular custo de frete de planta para armazem através de distância"""

from pyomo.environ import *
model = ConcreteModel()

#inicializa os conjuntos
model.P = Set(initialize=P) # plantas
model.L = Set(initialize=Lines) # Linhas
model.W = Set(initialize=W) # armazens
model.C = Set(initialize=C) # clientes
model.I = Set(initialize=I) # produtos
model.T = Set(initialize=T) # periodos
model.E = Set(initialize=tamanhos) # tamanhos

#inicializa os parâmetros
model.G_w = Param(model.W, initialize=G_w) # capacidade maxima de estoque no armzem w
model.G_p = Param(model.P, initialize=G_p) # capacidade maxima de estoque na planta p
model.h = Param(initialize=holding_cost) # custo de estoque por unidade por periodo
model.M = Param(initialize=M) # penalizador de demanda
model.Q = Param(initialize=truck_capacity) # capacidade maxima por caminhao
model.k = Param(model.E,model.L,model.T, initialize=taxas, default= 0) # capacidade produtiva de cada linha
model.t_pp = Param(model.P, model.P, initialize=t_pp, default=1e20) # custos  de frete
model.t_pc = Param(model.P, model.C, initialize=t_pc, default=1e20) # custos de frete
model.t_wc = Param(model.W, model.C, initialize=t_wc, default=1e20) # custos de frete
model.t_pw = Param(model.P, model.W, initialize=t_pw, default=1e20) #custos de frete
model.D = Param(model.C, model.I,model.T, initialize=D, default=0) # demandas
model.estoque_inicial_p = Param(model.P, initialize=estoque_inicial_p)
model.estoque_inicial_w = Param(model.W, initialize=estoque_inicial_w)

#incializar as variaveis

model.x = Var(model.I , model.L , model.T, domain=NonNegativeReals)
model.x_p = Var(model.I , model.P , model.T , domain=NonNegativeReals)
model.S_p = Var(model.I, model.P, model.T, domain=NonNegativeReals)
model.S_w = Var(model.I, model.W, model.T, domain=NonNegativeReals)
model.f_pc = Var(model.I, model.P, model.C, model.T, domain=NonNegativeReals)
model.f_wc = Var(model.I, model.W, model.C, model.T, domain=NonNegativeReals)
model.f_pp = Var(model.I, model.P, model.P, model.T ,domain=NonNegativeReals)
model.f_pw = Var(model.I, model.P, model.W, model.T  ,domain=NonNegativeReals)
model.U = Var(model.C, model.I, model.T, domain=NonNegativeReals)

# NOVO: Variaveis inteiras para o número de caminhões
# model.y_pc = Var(model.I, model.P, model.C, model.T, domain=NonNegativeIntegers)
# model.y_wc = Var(model.I, model.W, model.C, model.T, domain=NonNegativeIntegers)
# model.y_pp = Var(model.I, model.P, model.P, model.T ,domain=NonNegativeIntegers)
# model.y_pw = Var(model.I, model.P, model.W, model.T  ,domain=NonNegativeIntegers)

# definir funcao objetivo

def total_cost(m):
      # custo de frete Planta-Cliente
      cost_f_pc = sum(m.t_pc[p,c]* m.f_pc[i,p,c,t]
                      for i in m.I for p in m.P for c in m.C for t in m.T)
      # custo de frete Armazem-Cliente
      cost_f_wc = sum(m.t_wc[w, c] * m.f_wc[i, w, c, t]
                    for i in m.I for w in m.W for c in m.C for t in m.T)

      # custo de frete Planta-Planta
      cost_f_pp = sum(m.t_pp[p1, p2] * m.f_pp[i, p1, p2, t]
                    for i in m.I for p1 in m.P for p2 in m.P if p1 != p2 for t in m.T) # Adicionado if p1 != p2 para evitar frete de planta para ela mesma

      # custo de frete Planta-Armazem
      cost_f_pw = sum(m.t_pw[p, w] * m.f_pw[i, p, w, t]
                    for i in m.I for p in m.P for w in m.W for t in m.T)

      # custo de estoque no Armazem
      cost_h_w = sum(m.h * m.S_w[i,w,t]
                     for i in m.I for w in m.W for t in m.T)

      # custo de penalidade por demanda nao atendida
      cost_unmet_demand = m.M * sum(m.U[c,i,t]
                                    for c in m.C for i in m.I for t in m.T)

      return cost_f_pc + cost_f_wc + cost_f_pp + cost_f_pw + cost_h_w + cost_unmet_demand


model.obj = Objective(rule=total_cost, sense=minimize)

# definir as restrições

# 1) restricao de producao
model.Producao = ConstraintList()
for t in model.T:
  for l in model.L:
      for e in model.E:
        model.Producao.add(expr = sum(model.x[i,l,t] for i in model.I if size_of_products.get(i) == e) <= model.k[e,l,t])

# Restrição para definir x_p como a soma da produção por planta
model.Definicao_x_p = ConstraintList()
for i in model.I:
  for p in model.P:
    for t in model.T:
      model.Definicao_x_p.add(expr = model.x_p[i, p, t] == sum(model.x[i, l, t] for l in model.L if p_l[l] == p))



# 2) restricao de balanco de estoque na planta
# Para o primeiro período (t=1), consideramos o estoque inicial como 0
model.Balanco_estoque_planta = ConstraintList()
for p in model.P:
  for i in model.I:
    # Assuming T starts from 1
    first_period = min(model.T)
    model.Balanco_estoque_planta.add(
        expr = model.estoque_inicial_p[p] + model.x_p[i, p, first_period] + sum(model.f_pp[i, q, p, first_period] for q in model.P if q != p) ==
               model.S_p[i, p, first_period] + sum(model.f_pw[i, p, w, first_period] for w in model.W) + sum(model.f_pc[i, p, c, first_period] for c in model.C) + sum(model.f_pp[i, p, q, first_period] for q in model.P if q != p)
    )

# Para os períodos subsequentes (t > 1)
for t in model.T:
  if t > min(model.T):
    previous_period = list(model.T)[list(model.T).index(t) - 1]
    for p in model.P:
      for i in model.I:
        model.Balanco_estoque_planta.add(
            expr = model.S_p[i, p, previous_period] + sum(model.x_p[i, p, t] for l in model.L) + sum(model.f_pp[i, q, p, t] for q in model.P if q != p) ==
                   model.S_p[i, p, t] + sum(model.f_pw[i, p, w, t] for w in model.W) + sum(model.f_pc[i, p, c, t] for c in model.C) + sum(model.f_pp[i, p, q, t] for q in model.P if q != p)
        )


# 3)restricao de balanco de estoque no armazem
# Para o primeiro período (t=1), consideramos o estoque inicial como 0
model.Balanco_estoque_armazem = ConstraintList()
first_period = min(model.T)
for w in model.W:
  for i in model.I:
    model.Balanco_estoque_armazem.add(
        expr =  model.estoque_inicial_w[w] + sum(model.f_pw[i, p, w, first_period] for p in model.P) ==
               model.S_w[i, w, first_period] + sum(model.f_wc[i, w, c, first_period] for c in model.C)
    )

# Para os períodos subsequentes (t > 1)
for t in model.T:
  if t > min(model.T):
    previous_period = list(model.T)[list(model.T).index(t) - 1]
    for w in model.W:
      for i in model.I:
        model.Balanco_estoque_armazem.add(
            expr = model.S_w[i, w, previous_period] + sum(model.f_pw[i, p, w, t] for p in model.P) ==
                   model.S_w[i, w, t] + sum(model.f_wc[i, w, c, t] for c in model.C)
        )


# 4) restricao de estoque maximo na planta
model.Estoque_maximo_p = ConstraintList()
for p in model.P:
  for t in model.T:
    model.Estoque_maximo_p.add(
        expr = sum(model.S_p[i, p, t] for i in model.I) <= model.G_p[p]
    )


# 5) restricao de estoque maximo no armazem
model.Estoque_maximo_w = ConstraintList()
for w in model.W:
  for t in model.T:
    model.Estoque_maximo_w.add(
        expr = sum(model.S_w[i, w, t] for i in model.I) <= model.G_w[w]
    )


# 6) restricao de demanda
model.Demanda = ConstraintList()
for c in model.C:
  for i in model.I:
    for t in model.T:
      model.Demanda.add(
          expr = sum(model.f_pc[i, p, c, t] for p in model.P) + sum(model.f_wc[i, w, c, t] for w in model.W) + model.U[c,i,t] >= model.D[c, i, t]
          )

import gurobipy

solver = SolverFactory('gurobi')

solver.solve(model)
# Obtém o valor do objetivo
objective_value = model.obj()
# Divide por 1 trilhão para obter o valor em trilhões (1e12)

# Formata o valor em trilhões com um número fixo de casas decimais e adiciona a unidade
# Por exemplo, formatar com 2 casas decimais:
print(f"Valor do objetivo : {objective_value:.2f} ")

# Imprimir o valor das variáveis U[c,i,t]
unmet_demand_total = 0
unmet_demands = {}
print("Valores das variáveisc U[c,i,t]:")
for c in model.C:
  for i in model.I:
    for t in model.T:
      U = model.U[c,i,t].value
      unmet_demand_total += U
      if U != 0:
        unmet_demands[(c,i,t)] = U
      print(f"U[{c},{i},{t}] = {U}")



print(f"Total unmet demand: {unmet_demand_total}")
print(f"Total cost of operation: {objective_value - unmet_demand_total*M}")
unmet_demands